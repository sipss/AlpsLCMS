---
title: 'NIHS IBEC plasma dataset'
author: "Ibec team"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    df_print: paged
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Pipeline preparation

```{r}
library(NIHSlcms)
library(RAMClustR)
library(xcms)
```

```{r}
# Where converted samples are.
input_dir <- "C:/Users/hgrac/Desktop/cosas/IBEC/NIHSI/positive"

# Where output will be stored.
output_dir <- "C:/Users/hgrac/Desktop/cosas/IBEC/NIHSI/results_pos"

# Where converted samples are.
#input_dir <- "C:/Users/fmadrid/Documents/IBEC/NESTLE/LCMS/20200128_Data_IBEC_Plasma_LCMS/RAW_Data/For_IBEC/proteowin/positive"

# Where output will be stored.
#output_dir <- "C:/Users/fmadrid/Documents/IBEC/NESTLE/LCMS/20200128_Data_IBEC_Plasma_LCMS/RAMClustR/results_pos"
```


# NODE 1: Data wrangling

## Convert RAW to mzXML

First, we need the listed spectra in ".mzXML" format to create the `lcms_dataset`. We manually converted ".raw" into ".mzXML" using RawConverter externally and saved them within the same input directory. 

## Input

```{r}
# Where converted samples are.
path <- input_dir

# The format of LC-MS files to list (or list and convert).
file_format <- "mzXML"

# Directory where the RawConverter is.
# We recommend converting files outside R and set this to NULL
rawconverter <- "C:/Users/hgrac/AppData/Local/Apps/2.0/0W3LE4AA.3V9/HAK1HQ15.LLV/rawc..tion_0000000000000000_0001.0001_1563e82fa65e7a77/RawConverter.exe"
#rawconverter <- "C:/Users/fmadrid/Documents/IBEC/NESTLE/LCMS/RawConverter_x64/RawConverter.exe"
```

## Code to run: list of samples

```{r}
samples_mzxml <- lcms_list_mzxml_samples(path, file_format = file_format,
                                    rawconverter = rawconverter)
samples_mzxml = as.character(samples_mzxml)
```

## Code to run (II): creating the dataset object

```{r Data wrangling}
# Be careful setting the mode to "onDisk" when you apply this function.
dataset <- suppressWarnings(lcms_read_samples(samples_mzxml, mode = "onDisk"))
message("Is the dataset correctly loaded? \n")
cat("\n")
print(dataset)
```

## Save results to disk

```{r}
output_dir_node1 <- file.path(output_dir, "01-load-samples")
fs::dir_create(output_dir_node1)

dataset_rds <- fs::path(output_dir_node1, "dataset.rds")
lcms_dataset_save(dataset, dataset_rds)
```



# NODE 2: Append metadata

It requires a column ("sampleNames") with the same name of the files, **ending with the format (e.g. So1.mzXML)**.

It requires a column ("treatment") with the class sample. Ensure you have this specific colname **"treatment"**.

Caution with metadata. The use of characters such as "-", "/", " " (space) and starting with **numbers**, etc. leads to problems. Therefore, the function replace `[\\\"\\s/\\\\,;.:|#@$%&?!*%+-=><^'(){}\\[\\]]+` by `_`. Beware of using other special characters and change them by usual ASCII characters.

## Input parameters

```{r}
# Loading the metadata. # Be careful, include a column "sampleNames" ending with the format (e.g. So1.mzXML)
metadata <- readxl::read_excel("C:/Users/hgrac/Desktop/cosas/IBEC/NIHSI/20200128_Sample_Info_adapted.xlsx")
#metadata <- readxl::read_excel("C:/Users/fmadrid/Documents/IBEC/NESTLE/LCMS/20200128_Data_IBEC_Plasma_LCMS/20200128_Sample_Info_adapted.xlsx")
```

## Code to run

```{r}
dataset <- lcms_meta_add(dataset, metadata, by = "sampleNames")
phData(dataset)
```

## Save results to disk

```{r}
output_dir_node2 <- file.path(output_dir, "02-add-metadata")
fs::dir_create(output_dir_node2)

dataset_rds <- fs::path(output_dir_node2, "dataset.rds")
lcms_dataset_save(dataset, dataset_rds)

lcms_meta_export(dataset, fs::path(output_dir_node2, "metadata.xlsx"))
```

# Filtering Data

We filter by:
  * Polarity (NODE 3)
  * Scan or m/z range
  * Retention time / m/z (NODE 4)
  * Sample / Sample type (NODE 4)



# NODE 3: Split dataset

The experimental setup is using fast polarity switching, polarities are written interleaved in the data file.
We start by filtering the polarities.

## Check polarity

```{r}
positive_polarity = c(1,1,1,1)
actual_polarity = dataset@featureData@data[["polarity"]][1:4]

message("dataset polarity is positive: ", all.equal(actual_polarity, positive_polarity))
cat("\n")
length(dataset@featureData@data[["polarity"]])
```

# Filtering Mass range scans

Due to an overlaping in the adquisition, we implemented a new function to filter by spectra. However, in the R object there is not information about the Mass scan used. Since the spectra are sorted by sample and by range, we filtered out by the order.

```{r Filtering}
head(dataset@featureData@data[["lowMZ"]])
head(dataset@featureData@data[["highMZ"]])

number_Spec <- length(dataset@featureData@data[["polarity"]])
selection = rep(1:2, times = number_Spec/2)
Select <- dataset@featureData@data[["acquisitionNum"]]
names(Select) <- selection

sel <- Select[names(Select)==1]
sel2 <- Select[names(Select)==2]

names(sel2) <- NULL
length(sel2)

dataset_pos_73_350 <- filterAcquisitionNum(dataset, sel)
dataset_pos_350_900 <- filterAcquisitionNum(dataset, sel2)

head(dataset_pos_73_350@featureData@data[["lowMZ"]])
head(dataset_pos_73_350@featureData@data[["highMZ"]])
```

## TICs small mass range (73-350 m/z)

```{r}
# rm(dataset)
tics_pos <- lcms_tics(dataset_pos_73_350, treatment = "treatment")

lcms_plot_tics(tics_pos,
               treatment = treatment, 
               plot_type = "spec")

lcms_plot_tics(tics_pos[tics_pos$ret_time > 1 & tics_pos$ret_time < 700,],
               treatment = treatment,
               plot_type = "spec")

lcms_plot_tics(tics_pos, treatment = treatment,
               plot_type = "boxplot")
```


## TICs large mass range (350-900 m/z)

```{r}
tics_pos <- lcms_tics(dataset_pos_350_900,
                      treatment = "treatment")

lcms_plot_tics(tics_pos, 
               treatment = treatment, 
               plot_type = "spec") 

lcms_plot_tics(tics_pos[tics_pos$ret_time > 1 & tics_pos$ret_time < 700,], 
               treatment = treatment, 
               plot_type = "spec") 

lcms_plot_tics(tics_pos, 
               treatment = treatment, 
               plot_type = "boxplot")
```


## Save results

```{r}
output_dir_node3 <- file.path(output_dir, "03-split-mass_ranges")
fs::dir_create(output_dir_node3)

positive_dataset_rds1 <- fs::path(output_dir_node3, "positive_dataset_73_350.rds")
lcms_dataset_save(dataset_pos_73_350, positive_dataset_rds1)

positive_dataset_rds2 <- fs::path(output_dir_node3, "positive_dataset_350_900.rds")
lcms_dataset_save(dataset_pos_350_900, positive_dataset_rds2)

lcms_meta_export(dataset_pos_73_350, fs::path(output_dir_node3, "metadata.xlsx"))
```



# NODE 4: Filtering

## Filter by retention time / m/z

For coherence with the pipeline, time is measured in minutes. `XCMS` and `IPO` packages work in seconds by default, while `CAMERA` and `MAIT` in minutes. Under the hood, the still do in this way, but we preset all our results in minutes. 


## Input

```{r}
# Range of the retention time (minutes) to include in further analyses
rt = c(1.6, 15.5)
ms = c(350, 900)
```

## Code to run

```{r}
dataset_pos_73_350 <- lcms_filter_rt_min(dataset_pos_73_350, 
                                         rt = rt)
dataset_pos_350_900 <- lcms_filter_rt_min(dataset_pos_350_900, 
                                          rt = rt)
dataset_pos_350_900 <- lcms_filter_mz(dataset_pos_350_900, 
                                      mz = ms)
```


## Filter by sample condition

It is required to distinguish between regular samples, blank samples and Quality Control (QC) samples. Blank samples should be excluded in the alignment and grouping steps. Hence, this function filter different samples types:
  * Regular samples
  * Blank samples
  * Quality Control samples

## Input

```{r}
concentrated_S <- xcms::filterFile(dataset_pos_73_350, 
                             file = c("Plasma6.mzXML",
                                      "Plasma18.mzXML",
                                      "Plasma10.mzXML"))
concentrated_L <- xcms::filterFile(dataset_pos_350_900, 
                             file = c("Plasma6.mzXML",
                                      "Plasma18.mzXML",
                                      "Plasma10.mzXML"))

especial_samples = list(QC = NULL)
```


## Save results

```{r}
output_dir_node4 <- file.path(output_dir, "04-filtered-samples")
fs::dir_create(output_dir_node4)

lcms_meta_export(dataset_pos_73_350, 
                 fs::path(output_dir_node4, 
                          "metadata.xlsx"))

pos_dataset_rds1 <- fs::path(output_dir_node4,
                             "dataset_pos_73_350.rds")

lcms_dataset_save(dataset_pos_73_350, 
                  pos_dataset_rds1)

positive_dataset_rds2 <- fs::path(output_dir_node3,
                                  "positive_dataset_350_900.rds")

lcms_dataset_save(dataset_pos_350_900, 
                  positive_dataset_rds2)
```


# NODE 5: Optimization of parameters

## Optimization of **Peak Detection** parameters

Here, we try to fit the parameters obtained from the positive mode.


## Input

```{r Optimize}
output_dir_node5_p <- file.path(output_dir, "05-optimization_pos")
fs::dir_create(output_dir_node5_p)

# if to optimize or not
optimize = FALSE

# number of rounds, by default nSlaves = 1 because does the necessary to find the optimum
nSlaves = 1
```

## Code to run

```{r}
default_peakpeaking_params <- lcms_default_peakpicking_params(optimize = optimize)
# 
# default_peakpeaking_params$prefilter <- 3 
# default_peakpeaking_params$value_of_prefilter <- 1000
# default_peakpeaking_params$integrate <- 1
# 
resultPeakpicking_p<- lcms_peakpicking_optimization(
  dataset = concentrated_S,
  peakpickingParameters = default_peakpeaking_params,
  nSlaves = nSlaves,
  opt_path = output_dir_node5_p,
  plots = TRUE)
```

###Peak optimization results are stored in the variable `optimizedXcmsSetObject`

```{r}
optimizedXcmsSetObject_p <- resultPeakpicking_p$best_settings$xset
```

## Save results

```{r}
resultPeakpicking_optP_rds <- fs::path(output_dir_node5_p,
                                      "resultPeakpicking_opt_p.rds")
lcms_dataset_save(resultPeakpicking_p,
                  resultPeakpicking_optP_rds)

optimizedXcmsSetObjectP_rds <- fs::path(output_dir_node5_p,
                                    "optimizedXcmsSetObject_p.rds")

lcms_dataset_save(optimizedXcmsSetObject_p,
                  optimizedXcmsSetObjectP_rds)
```

## Optimization of **retention time correction** and **grouping** parameters

## Input: We set them manually (optimize = FALSE)

```{r}
optimize = FALSE
nSlaves = 1

output_dir_node5_p
```

## Code to run (I)

```{r}
retcorGroupParameters <- lcms_default_retcorgroup_params(optimize = optimize)
# retcorGroupParameters$gapExtend <- c(2.1,2.7)
# retcorGroupParameters$minfrac <- c(0.2, 0.7)
# retcorGroupParameters$gapInit <- c(0,0.5)

# retcorGroupParameters$gapExtend <- c(2.1,2.7)

# profStep get and set the m/z step for generating profile (matrix) data
# from raw mass spectral data. Smaller steps yield more precision at the cost of
# greater memory usage.
# retcorGroupParameters$profStep <- c(0.05, 1)## decrease the bin size to get better resolution

## You need to use this twice with different values in alignment and grouping.
## In alignment we use below a value of 0.4 for the minFraction parameter hence only
## chromatographic peaks present in at least 40% of the samples per sample group
## are grouped into a feature.
# retcorGroupParameters$minfrac <- 0.8 # for retention time

# retcorGroupParameters$gapInit <- c(0,0.5)

## bw Different values for the bw parameter of the PeakDensityParam were used:bw =
## 30 in the middle and bw = 20 in the lower panel. With the default value for
## the parameter bw the two neighboring chromatographic peaks would be grouped
## into the same feature, while with a bw of 20 they would be grouped into
## separate features. This grouping depends on the parameters for the density
## function and other parameters passed to the algorithm with the
## PeakDensityParam.
# retcorGroupParameters$bw <- c(20, 30)
```

## Code to run (II)

```{r}
resultRetcorGroup_p  <- lcms_retcorgroup_optimization(
  optimizedXcmsSetObject = optimizedXcmsSetObject_p,
  retcorGroupParameters = retcorGroupParameters,
  nSlaves = nSlaves,
  opt_path = output_dir_node5_p,
  subdir = "plot_ipo",
  plots = TRUE
)
```

## Save results

```{r}
resultRetcorGroup_optP_rds <- fs::path(output_dir_node5_p,
                                      "resultRetcorGroup_opt_p.rds")
lcms_dataset_save(resultRetcorGroup_p,
                  resultRetcorGroup_optP_rds)

### Important file
IPO_params_p = lcms_write_opt_params(resultPeakpicking_p, 
                                     resultRetcorGroup_p, 
                                     output_dir_node5_p)
```



# NODE 6: Conversion to xcms and data rearrange

First, we need the conversion from `IPO` to `XCMS` variable formats to achieve compatibility between packages. To do that, we need to read the IPO_params from the last step and convert into XCMS frame.

# Data rearrange

## Input

```{r}
output_dir_node6_p <- file.path(output_dir,
                                "06-rearrange-POS")
fs::dir_create(output_dir_node6_p)
project <- "LUMOS"
```

## Code to run

```{r Rearrange}
lcms_rearrange_datafiles_by_class(dataset = dataset_pos_73_350, 
                                  dataDir = output_dir_node6_p)
```

```{r}
fileList <- base::list.files(
  path = paste(output_dir_node6_p,
               list.files(path = output_dir_node6_p),
               sep = "/"),
  full.names = TRUE)

fileList[1:3]
```

## Positive mode:73-350 m/z

```{r}
dataset_pos_73_350 <- lcms_read_samples(fileList,
                                        mode = "onDisk")

dataset_pos_73_350 <- lcms_meta_add(dataset_pos_73_350, 
                                    metadata, 
                                    by = "sampleNames")
phData(dataset_pos_73_350)
```



# NODE 7: Data Preprocessing - XCMS

It includes:

  * Peak Detection
  * Retention Time Correction
  * Peak Correspondence
  * Imputation

Parameters can be changed here. After manual inspection of certain compounds that we know that they should naturally appear, such as plotting leucine and isoleucine (as we are using plasma samples), we can set parameters more accurally. 

## Checking (Leu)cine at 5.8 min and 132.102 m/z

```{r}
metabolite <- "(iso)Leucine"
retention_time <- 5.8
mz <- 132.1021
dataset <- dataset_pos_73_350
```
## Code to run

```{r}
retention_time_max <- (retention_time*60)+120
retention_time_min <- (retention_time*60)-120
rtr <- c(retention_time_min, retention_time_max)

mz_max <- mz + 0.01
mz_min <- mz - 0.01
mzr <- c(mz_min, mz_max)

## extract the chromatogram
chr_raw_leucines <- chromatogram(dataset, mz = mzr, rt = rtr)
plot(chr_raw_leucines, col = "blue", main = metabolite)
plot(chr_raw_leucines, col = "blue", xlim = c(330,370), ylim = c(0,1e+8), main = metabolite)
plot(chr_raw_leucines[[2]], col = "blue", xlim = c(330,370), ylim = c(0,1e+8), main = metabolite)
```


## Checking Glutathione (GSH) at 8.59 min and 308.091 m/z

## Input

```{r}
retention_time <- 8.59
mz <- 308.091
dataset <- dataset_pos_73_350
```


```{r}
retention_time_max <- (retention_time*60)+120
retention_time_min <- (retention_time*60)-120
rtr <- c(retention_time_min, retention_time_max)

mz_max <- mz + 0.01
mz_min <- mz - 0.01
mzr <- c(mz_min, mz_max)

## extract the chromatogram
chr_raw_gsh <- chromatogram(dataset, mz = mzr, rt = rtr)
plot(chr_raw_gsh, col = "red", main = "GSH")
plot(chr_raw_gsh, col = "red", xlim = c(500, 525), main = "GSH")
```

We observe that the peak width can be from 10 (s) to 50-60 (s) depending on the concentration. Likewise, the noise level ranges from 5ee+3 to 1e+6. We can set the lowest one as we have a second parameter that acts as a second condition. The prefilter parameter allows an added condition in which you need at least several datapoints at this intensity to become a peak.


## Input

```{r Creating parameters}
output_dir_node5_p <- file.path(output_dir, "05-optimization_pos")
directory_params_p <- output_dir_node5_p

prep_parm_p <- lcms_read_ipo_to_xcms(directory_params_p)
prep_parm_p$peakwidth <- c(8, 60)
prep_parm_p$noise <- 1e+4
prep_parm_p$snthresh <- 3
prep_parm_p$prefilter <- c(3, 1e+4)
prep_parm_p$centerSample <- 1 # index of the center sample.
prep_parm_p$integrate <- 2
prep_parm_p$mzdiff <- -0.001
prep_parm_p$profStep <- 0.005
prep_parm_p$minFraction <- 0.2

classesS <- dataset_pos_73_350@phenoData@data[["treatment"]]
classesL <- dataset_pos_350_900@phenoData@data[["treatment"]]
```

# **Peak detection**

Our standard method for peak detection is *'CentWave'*, since the data provided is Centroided. We must initialize its parameters according to the `IPO` Package optimization. Peak detection aims to detect important features (peaks) on the chromatographic axis. This will be useful for a posterior peak alignment on the chormatophic axis.

## Code to run

## Small range

```{r Peak detection}
peakdet_pos_73_350 = lcms_find_chrom_peaks_cwp(dataset_pos_73_350, 
                                            params = prep_parm_p)

message("Number of detected peaks")
peakdet_pos_73_350@msFeatureData[["chromPeakData"]]@nrows
message("")

message("Parameters")
peakdet_pos_73_350@.processHistory[[1]]@param
```


## Large range

```{r Peak detection II}
peakdet_pos_350_900 = lcms_find_chrom_peaks_cwp(dataset_pos_350_900,
params = prep_parm_p)

message("Number of detected peaks")
peakdet_pos_350_900@msFeatureData[["chromPeakData"]]@nrows
message("")

message("Parameters")
peakdet_pos_350_900@.processHistory[[1]]@param
```


# **Retention Time Correction and Peak Correspondence**

Peak correspondence is carried out by the *'groupChromPeaks'* method, with parameters obtained form `IPO`. Peak Correspondece consist in grouping peaks on retention time axis with the purspose of associate them to spectra on the mass/chage axis. After this stage we finally have a peak table.

It requires a previous grouping.

# **Correspondence, Alignment and Regrouping (small range)**

## Input

```{r}
centerSample <- 4 # index of the center sample. It defaults to floor(median(1:length(fileNames(object))))


## bw Different values for the bw parameter of the PeakDensityParam were used:bw =
## 30 in the middle and bw = 20 in the lower panel. With the default value for
## the parameter bw the two neighboring chromatographic peaks would be grouped
## into the same feature, while with a bw of 20 they would be grouped into
## separate features. This grouping depends on the parameters for the density
## function and other parameters passed to the algorithm with the
## PeakDensityParam.
# prep_parm_p$bw <- 10

# prep_parm_p$profStep <- 0.005

# prep_parm_p$minFraction <- 0.2 # does not change with lcms_align_rtime. It is used for density.
```

## **Correspondence (small range)**

```{r Correspondence}
###################################################################
## CORRESPONDENCE

new_params <- PeakDensityParam(sampleGroups = classesS,
                               bw = 5, 
                               minFraction = 0.2,
                               minSamples = 1, 
                               binSize = 0.005, 
                               maxFeatures = 50)

peakgrouped_pos_73_350 = groupChromPeaks(peakdet_pos_73_350, 
                                         param = new_params)
```


## **Alignment and regrouping (small range)**


```{r Alignment}
###################################################################
## ALIGNMENT

pgp <- PeakGroupsParam(minFraction = 0.4,
                       extraPeaks = 1, #maximal number of additional peaks for all samples to be assigned to a peak group (i.e. feature) for retention time correction.
                       smooth = "loess", # interpolate corrected retention times
                       # span = , # degree of smoothing (if smooth = "loess")
                       family = "gaussian",
                       subset = as.integer(                       rownames(as.data.frame(concentrated_S@phenoData@data)))) # indices of samples within the experiment on which the alignment models should be estimated.

## Get the peak groups that would be used for alignment.
xdataS <- adjustRtime(peakgrouped_pos_73_350, param = pgp)

rt_plotS = lcms_retention_time_alignment_plot(xdataS)

# print(rt_plotS)


###################################################################
## REGROUPING

new_params <- PeakDensityParam(sampleGroups = classesS,
                               bw = 5, # 
                               minFraction = 0.2,
                               minSamples = 1,
                               binSize = 0.005,
                               maxFeatures = 50)

peakgrouped_pos_73_350 = groupChromPeaks(xdataS, param = new_params)

rm(xdataS)
```


## **Correspondence (large range)**

## Code to run

```{r Correspondence II}
###################################################################
## CORRESPONDENCE

new_params <- PeakDensityParam(sampleGroups = classesL,
                               bw = 5, 
                               minFraction = 0.2,
                               minSamples = 1, 
                               binSize = 0.005, 
                               maxFeatures = 50)

peakgrouped_pos_350_900 = groupChromPeaks(peakdet_pos_350_900, 
                                         param = new_params)
```

## **Alignment and regrouping (large range)**

```{r Alignment II}
###################################################################
## ALIGNMENT

## Now the retention time correction.
pgpL <- PeakGroupsParam(minFraction = 0.4,
                       extraPeaks = 1, #maximal number of additional peaks for all samples to be assigned to a peak group (i.e. feature) for retention time correction.
                       smooth = "loess", # interpolate corrected retention times
                       # span = , # degree of smoothing (if smooth = "loess")
                       family = "gaussian",
                       subset = as.integer(                       rownames(as.data.frame(concentrated_L@phenoData@data)))) # indices of samples within the experiment on which the alignment models should be estimated.

## Get the peak groups that would be used for alignment.
xdataL <- adjustRtime(peakgrouped_pos_350_900, param = pgpL)

rt_plotL = lcms_retention_time_alignment_plot(xdataL)
# print(rt_plotL)


###################################################################
## REGROUPING

new_params <- PeakDensityParam(sampleGroups = classesL,
                               bw = 5, # 
                               minFraction = 0.2,
                               minSamples = 1,
                               binSize = 0.005,
                               maxFeatures = 50)

peakgrouped_pos_350_900 = groupChromPeaks(xdataL,
                                          param = new_params)
rm(xdataL)
```

## Base Peak

**Base peak chromatograms** before and after retention time aligment and grouping. Again, we modified the plot measuring the retention time axis in minutes.

Chromatogram of the detected peaks per sample **before** and **after** time alignment and grouping:

```{r Base peak}
base_peaks_beforeS <- chromatogram(peakdet_pos_73_350,
                                        aggregationFun = "max")

#TOCHECK: error
#base_peaks_afterS <-  xcms::chromatogram(peakgrouped_pos_73_350,
#                                       aggregationFun = "max")

base_peaks_beforeL <- chromatogram(peakdet_pos_350_900,
                                        aggregationFun = "max")

base_peaks_afterL <-  chromatogram(peakgrouped_pos_350_900,
                                       aggregationFun = "max")
```

## Code to run

```{r}
treatment_col <- scales::hue_pal()(length(unique(dataset_pos_73_350$treatment)))
names(treatment_col) <- unique(dataset_pos_73_350$treatment)

lcms_plot_chrom(base_peaks_beforeS, 
                treatment_col = treatment_col)
lcms_plot_chrom(base_peaks_afterS, 
                treatment_col = treatment_col)
```

## Large range

```{r}
lcms_plot_chrom(base_peaks_beforeL, treatment_col = treatment_col)
lcms_plot_chrom(base_peaks_afterL, treatment_col = treatment_col)
```

```{r}
# tics_before <- lcms_tics(peakdet_pos_73_350, treatment = "treatment")
# tics_after <- lcms_tics(peakgrouped_pos_73_350, treatment = "treatment")
# #
# #
# lcms_plot_tics(tics_before, treatment = treatment, plot_type = "spec")
# lcms_plot_tics(tics_after, treatment = treatment, plot_type = "spec")
# 
# lcms_plot_tics(tics_before[tics_before$ret_time > 350 & tics_before$ret_time < 700,],
#                treatment = treatment,
#                plot_type = "spec")
# 
# lcms_plot_tics(tics_after[tics_after$ret_time > 350 & tics_after$ret_time < 700,],
#                treatment = treatment,
#                plot_type = "spec")
```

## Small range

Image plot of the chromatographic detected peaks per sample before retention time alignment and grouping:

```{r}
lcms_plot_chrom_peak_image(peakdet_pos_73_350, binSize = 5,
                           xlim = NULL,
                           log = FALSE,
                           xlab = "retention time (min)",
                           yaxt = par("yaxt"),
                           main = "Detected Peaks (unprocessed)")

lcms_plot_chrom_peak_image(peakgrouped_pos_73_350, binSize = 5,
                           xlim = NULL,
                           log = FALSE,
                           xlab = "retention time (min)",
                           yaxt = par("yaxt"),
                           main = "Detected Peaks (processed)")
```

## Large range

```{r}
lcms_plot_chrom_peak_image(peakdet_pos_350_900, binSize = 5,
                           xlim = NULL,
                           log = FALSE,
                           xlab = "retention time (min)",
                           yaxt = par("yaxt"),
                           main = "Detected Peaks (unprocessed)")

lcms_plot_chrom_peak_image(peakgrouped_pos_350_900, binSize = 5,
                           xlim = NULL,
                           log = FALSE,
                           xlab = "retention time (min)",
                           yaxt = par("yaxt"),
                           main = "Detected Peaks (processed)")
```


```{r}
# summary_fun <- function(z){
#     c(peak_count = nrow(z), rt = quantile(z[, "rtmax"] - z[, "rtmin"]))
# }
# 
# peak_count <- lapply(split.data.frame(chromPeaks(peakgrouped_pos_73_350), 
#                                 f = chromPeaks(peakgrouped_pos_73_350)[, "sample"]),
#                FUN = summary_fun)
# 
# peak_count <- do.call(rbind, peak_count)
# sampleNames <- basename(fileNames(peakgrouped_pos_73_350))
# # rownames(peak_count) <- basename(fileNames(peak_table_pos_73_350))
# peak_count <- data.frame(sampleNames, peak_count, stringsAsFactors = FALSE)
# peak_count <- dplyr::left_join(peak_count, phData(peakgrouped_pos_73_350), by = "sampleNames")
#   
# pander::pandoc.table(peak_count, caption = paste0("Summary statistics on identified chromatographic",
#                               " peaks. Shown are number of identified peaks per",
#                               " sample and widths/duration of chromatographic ",
#                               "peaks."))
```

# *Imputation*

Finally, in the imputation stage, we integrate the areas of the missing peaks of the peak table that were not detected in the previous steps of the signal preprocessing workflow. This stage is important to make easier statistical and machine learnig posterior stages. 

## Small range

```{r Imputation I}
message("Missing values found in the processed dataset: ", sum(is.na(featureValues(peakgrouped_pos_73_350))))
peakgroupedPOS73_350imp <- lcms_fill_chrom_peaks(
  peakgrouped_pos_73_350)

cat("Imputing values...\n")

message("Missing values found after fill_chrom_peaks: ", sum(is.na(featureValues(peakgroupedPOS73_350imp))))
```

### Expansion FillChromPeaksParam

```{r message=FALSE, warning=FALSE}
# ph <- processHistory(peakgrouped_pos_73_350, type = "Missing peak filling")[[1]]
# 
# ## Drop the filled in peaks:
# res <- dropFilledChromPeaks(peakgrouped_pos_73_350)
# sum(is.na(featureValues(res)))
# 
# 
# # Perform the peak filling with modified settings: allow expansion of the mz range by a specified ppm and expanding the mz range by mz width/2
# prm <- FillChromPeaksParam(ppm = 20, expandMz = 0.5)
# peakgrouped_pos_73_350 <- base::suppressMessages(fillChromPeaks(res, param = prm))
# 
# ## Did we get a signal for all missing peaks?
# message("")
# cat("Missing values found: \n", sum(is.na(featureValues(peakgrouped_pos_73_350))))
```


## Large range

```{r Imputation II}
message("Missing values found in the processed dataset: ", sum(is.na(featureValues(peakgrouped_pos_350_900))))
peakgroupedPOS350_900imp <- lcms_fill_chrom_peaks(
  peakgrouped_pos_350_900)

cat("Imputing values...\n")
# fp <- chromPeaks(peakgrouped_pos_350_900)[chromPeakData(peakgrouped_pos_350_900)$is_filled, ]
message("Missing values found after fill_chrom_peaks: ", sum(is.na(featureValues(peakgroupedPOS350_900imp))))
```


### Expansion FillChromPeaksParam

```{r}
# ph <- processHistory(peakgrouped_pos_350_900, 
#                      type = "Missing peak filling")[[1]]
# 
# ## Drop the filled in peaks:
# res <- dropFilledChromPeaks(peakgrouped_pos_350_900)
# sum(is.na(featureValues(res)))
# 
# 
# # Perform the peak filling with modified settings: allow expansion of the mz range by a specified ppm and expanding the mz range by mz width/2
# prm <- FillChromPeaksParam(ppm = 20, expandMz = 0.5)
# peakgrouped_pos_350_900 <- base::suppressMessages(fillChromPeaks(res, param = prm))
# 
# ## Did we get a signal for all missing peaks?
# message("")
# cat("Missing values found: \n", sum(is.na(featureValues(peakgrouped_pos_350_900))))
```


## Save results

```{r}
output_dir_node7 <- file.path(output_dir, "07-data-preprocessing")
fs::dir_create(output_dir_node7)

##################################################################
# PEAK DETECTION
detected_peak_pos73_350rds <- fs::path(output_dir_node7, "detected_peaksPOS73_350.rds")
lcms_dataset_save(peakdet_pos_73_350, detected_peak_pos73_350rds)

detected_peak_pos350_900rds <- fs::path(output_dir_node7,
"detected_peaksPOS350_900.rds")
lcms_dataset_save(peakdet_pos_350_900, detected_peak_pos350_900rds)

##################################################################
# PEAK ALIGNMENT and GROUPING
aligned_peak_pos73_350rds <- fs::path(output_dir_node7,
                                      "aligned_peakPOS73_350.rds")
lcms_dataset_save(peakgrouped_pos_73_350,
                  aligned_peak_pos73_350rds)

aligned_peak_pos350_900rds <- fs::path(output_dir_node7,
                                      "aligned_peakPOS350_900.rds")
lcms_dataset_save(peakgrouped_pos_350_900,
                  aligned_peak_pos350_900rds)

##################################################################
# SEMI IMPUTED PEAK TABLE
peaktable_posS_rds <- fs::path(output_dir_node7,
                               "peakTablePOSimp73_350.rds")
lcms_dataset_save(peakgroupedPOS73_350imp,
                  peaktable_posS_rds)

peaktable_posL_rds <- fs::path(output_dir_node7,
                               "peakTablePOSimp350_900.rds")
lcms_dataset_save(peakgroupedPOS350_900imp,
                  peaktable_posL_rds)

# peak_count_fn <- file.path(output_dir_node7, "peak_count.csv")
# utils::write.csv(peak_count, peak_count_fn, row.names = FALSE)

rt_alignment_plot <- file.path(output_dir_node7, "rt_alignmentS_plot.png")
ggplot2::ggsave(filename = rt_alignment_plot, 
                plot = rt_plotS, 
                width = 14, 
                height = 8, 
                unit = "cm", 
                dpi = 300)

rt_alignment_plot <- file.path(output_dir_node7, "rt_alignmentL_plot.png")
ggplot2::ggsave(filename = rt_alignment_plot, 
                plot = rt_plotL, 
                width = 14, 
                height = 8, 
                unit = "cm", 
                dpi = 300)
```

## Cleaning

```{r}
rm(base_peaks_beforeS, base_peaks_afterS, base_peaks_beforeL, base_peaks_afterL)

rm(peakdet_pos_73_350,
   peakdet_pos_350_900, 
   peakgrouped_pos_73_350, 
   peakgrouped_pos_350_900)
```



# NODE 8: Feature table

The XCMS function featureValues creates a intensity matrix with all the features. However, since this is untargeted metabolomics, the colnames are composed by FT1, FT2, FT3... (FT = feature) and each feature needs to be explored with the feature definition function (info for mass and rt) once a feature is significantly different by groups.

## Merging into a Feature Table

```{r Feature table}
# Small range
xdata_73_350 = featureValues(peakgroupedPOS73_350imp,
                             method = "maxint",
                             value = "into",
                             filled = TRUE, 
                             missing = NA) # If "rowmin_half", the half of the row's minimal value replaces NAs.)
xdata_73_350= t(xdata_73_350)
feature=featureDefinitions(peakgroupedPOS73_350imp)
feature=feature@listData
featNames=paste0(feature$mzmed,"_",feature$rtmed)
colnames(xdata_73_350)=featNames

#Number of missing values after missing value imputation
sum(is.na(xdata_73_350))

#############
# Large range
xdata_350_900 = featureValues(peakgroupedPOS350_900imp,
                             method = "maxint",
                             value = "into",
                             filled = TRUE, 
                             missing = NA)
xdata_350_900= t(xdata_350_900)
feature=featureDefinitions(peakgroupedPOS350_900imp)
feature=feature@listData
featNames=paste0(feature$mzmed,"_",feature$rtmed)
colnames(xdata_350_900)=featNames

#Number of missing values after missing value imputation
sum(is.na(xdata_350_900))

## Final feature table
dfdata_73_350 <- as.data.frame(xdata_73_350)
dfdata_73_350$sampleNames <- rownames(xdata_73_350)
dfdata_350_900 <- as.data.frame(xdata_350_900)
dfdata_350_900$sampleNames <- rownames(xdata_350_900)

xdata <- merge(dfdata_73_350, 
                dfdata_350_900, 
                by = "sampleNames", 
                all  = TRUE)

rm(dfdata_73_350,dfdata_350_900)

message("Missing values in the feature table: ",
sum(is.na(xdata)))
```

## Deep Imputation by Random Forest

```{r Random Forest Imputation}
#Installation of package StatTools
# devtools::install_git("https://gitlab.com/CarlBrunius/StatTools.git")
#Missing Value Imputation

nCore <- detectCores()-1
cl <- makeCluster(nCore)
doParallel::registerDoParallel(cl)
xdataImp <- StatTools::mvImpWrap(MAT = xdata[,-1],
                                        method = "RF")
stopCluster(cl)

#Number of missing values after missing value imputation
sum(is.na(xdataImp))

xdataImpu <- as.data.frame(xdataImp)
xdataImputed <- cbind(sampleNames = xdata[,1], xdataImpu, stringsAsFactors = FALSE)

#############################################
# Get mz and rt columns for the feature table
mz <- colnames(xdataImp) %>%
  stringr::str_split(.,"\\_") %>% 
  lapply(.,function(x) x[1]) %>% 
  unlist() %>% 
  # substring(., 2) %>% # add if xdata was loaded (cols with an X)
  as.numeric()

rt <- colnames(xdataImp) %>%
  stringr::str_split(.,"\\_") %>% 
  lapply(.,function(x) x[2]) %>% 
  unlist() %>% 
  # substring(., 2) %>% # add if xdata was loaded (cols with an X)
  as.numeric()
rt <- rt/60

xdata_complete <- rbind(rt, xdataImp)
xdata_complete <- rbind(mz, xdata_complete)
xdata_complete <- cbind(sampleNames = c("mz", 
                                        "rt", 
                                        xdata[,1]),
                        xdata_complete)
xdata_complete <- as.data.frame(xdata_complete)

suppressWarnings(
  xdata_comp_meta <- dplyr::right_join(
    metadata, 
    xdata_complete, 
    by = "sampleNames", 
    all = TRUE))


##############################
# Get transposed feature table
tdata_complete <- t(as.matrix(xdata_complete))
colnames(tdata_complete) <- tdata_complete[1,]
tdata_complete <- tdata_complete[-1,]
tdata_complete_rows <- as.data.frame(x = tdata_complete,
                                stringsAsFactors = FALSE)
tdata_complete <- as.data.frame(sapply(tdata_complete_rows,
                                       as.numeric))
rownames(tdata_complete) <- rownames(tdata_complete_rows)

message("Feature table is correct?: ",
        all.equal(tdata_complete[1,1],
                  as.numeric(tdata_complete_rows[1,1])))

rm(tdata_complete_rows)

## Tables
# head(xdata)
head(xdataImputed)
head(xdata_complete)
head(xdata_comp_meta)
head(tdata_complete)
```


## Save results

```{r}
output_dir_node8 <- file.path(output_dir, "08-feature-table")
fs::dir_create(output_dir_node8)

# write.csv(xdata_73_350, 
#           file = paste0(getwd(), 
#                         "/xdata_73_350p.csv"))

head(xdata)
head(xdataImputed)
head(xdata_complete)
head(xdata_comp_meta)
head(tdata_complete)

xdata_fn <- file.path(output_dir_node8,
                              "xdataNOTimp.csv")
utils::write.csv(xdata, xdata_fn, row.names = FALSE)

xdataImputed_fn <- file.path(output_dir_node8,
                              "xdataImputed.csv")
utils::write.csv(xdataImputed, xdataImputed_fn, row.names = FALSE)

data_complete_fn <- file.path(output_dir_node8,
                              "feature_table.csv")
utils::write.csv(xdata_complete, data_complete_fn, row.names = FALSE)

xdata_comp_meta_fn <- file.path(output_dir_node8,
                              "feature_tableMeta.csv")
utils::write.csv(xdata_comp_meta, xdata_comp_meta_fn, row.names = FALSE)

tdata_complete_fn <- file.path(output_dir_node8,
                              "feature_tableT.csv")
utils::write.csv(tdata_complete, tdata_complete_fn, row.names = FALSE)


xdata_73_350.csv_fn <- file.path(output_dir_node8, "xdata_73_350.csv")
utils::write.csv(xdata_73_350, xdata_73_350.csv_fn, row.names = TRUE)
```

## Cleaning

```{r}
rm(xdata, tdata_complete)
```



# NODE 9: Data reduction

## Input

```{r Params Data reduction}
# devtools::install_github("cbroeckl/RAMClustR", build_vignettes = TRUE, dependencies = TRUE)

getRamSt <- function(XObj) {
  featInfo <- featureDefinitions(XObj)
  histo <- hist((featInfo$rtmax-featInfo$rtmin)/2)
  st <- round(median(featInfo$rtmax-featInfo$rtmin)/2,
              digits = 2)
  abline(v=st)
  return(st)
}
value_st <- getRamSt(peakgroupedPOS73_350imp)

sr <- 0.4
st <- value_st

### Building the defineExperiment manually
### Change for your convenience (e.g. GC-MS)
##########################################

value <- c(rep("fill", 4), "LC-MS")
design <- as.data.frame(value)
rownme <- c("Experiment", "Species", "Sample",
            "Contributer", "platform")  
rownames(design) <- rownme

######################################################

value <- c(rep("fill", 13), "1")
instrument <- as.data.frame(value)
rownm <- c("chrominst", "msinst", "column", 
           "solvA", "solvB", "CE1", "CE2", 
           "mstype", "msmode", "ionization", 
           "colgas", "msscanrange", "conevol", 
           "MSlevs")
rownames(instrument) <- rownm

Experiment <- list(design =  design, instrument = instrument)

output_dir_node9 <- file.path(output_dir, "09-data-reduction")
fs::dir_create(output_dir_node9)
```

## Code to run

```{r warning=FALSE}
knitr::opts_knit$set(root.dir = output_dir_node9)
# options(fftempdir = output_dir_node9)
setwd(output_dir_node9)

RC <- ramclustR(ms = paste0(output_dir_node8,"/xdataImputed.csv"),
                 featdelim = "_",
                 st = st,
                 sr = sr,
                 ExpDes = Experiment,
                 normalize = "TIC",
                 sampNameCol = 1,
                 fftempdir = output_dir_node9)

RC <- do.findmain(RC,
                   mode = "positive",
                   mzabs.error = 0.005,
                   ppm.error = 5,
                   writeMat = FALSE)
```

```{r}
Max_int<- lapply(RC$M.ann, function(x) x[which.max(x$int), ])
Molecular_ions <- dplyr::bind_rows(Max_int)
Molecular_ions$name <- paste(round(Molecular_ions$mz,4),
                             round(RC$clrt,2),
                             sep = "_")
```

```{r}
mz %in% Molecular_ions$mz %>% table()
message("length of features: ", length(mz))
```
```{r Reduced feature table}
id <- as.character(xdataImputed[,1])
mdataImputed <- xdataImputed[,-1]
mdataImputed <- as.matrix(mdataImputed)
rownames(mdataImputed) <- id

# Clustered features
xdata_mol_ions <- mdataImputed[, mz %in% Molecular_ions$mz]

# Singletons
clustered_mz<- lapply(RC$M.ann,
                      function (x) x$mz) %>% 
                      unlist() %>%
                      as.numeric()

message("A number of ",
        length(clustered_mz),
        " features have been clustered into ",
        dim(xdata_mol_ions)[2],
        " representative features")

mdataImputed <- as.data.frame(mdataImputed)
xdata_mol_ions <- as.data.frame(xdata_mol_ions)

singletons <- mdataImputed[,!mz %in% clustered_mz]#check xdata[,-1]



message("A number of ",
        ncol(singletons),
        " features correspond to singletons")

```

```{r}
#Combine singletons and molecular ions
xdata_reduced <- cbind.data.frame(xdata_mol_ions, singletons)

message("Original dataset has ", 
        ncol(mdataImputed), 
        " features")
message("")

message("Molecular ions dataset has ", ncol(xdata_mol_ions), 
        " features")
message("")

message("Singletons dataset has ", ncol(singletons), " features")
message("")

message("Reduced dataset has ", ncol(xdata_reduced), " features")
message("")
```


# Save results

```{r}
RC_rds <- fs::path(output_dir_node9, "clustering.rds")
lcms_dataset_save(RC, RC_rds)

xdata_mol_ions_fn <- file.path(output_dir_node9, "xdata_mol_ions.csv")
utils::write.csv(xdata_mol_ions, xdata_mol_ions_fn, row.names = TRUE)

xdata_singletons_fn <- file.path(output_dir_node9, "xdata_singletons.csv")
utils::write.csv(singletons, xdata_singletons_fn, row.names = TRUE)

xdata_reduced_fn <- file.path(output_dir_node9, "feature_table_reduced.csv")
utils::write.csv(xdata_reduced, xdata_reduced_fn, row.names = TRUE)
```

## Cleaning

```{r}
# rm(xdata_mol_ions, singletons, Max_int, RC)
```



# NODE 10: Annotation

HMDB metabolites in positive and negative ionization
The function compares (M+H & M-H) mass of metabolites contained in the The Human Metabolome Database (HMDB) (+- 1.007276) with features from the ionized feature table (window of +-0.002).

@param feature_table A dataframe containing feature in rows and samples in columns. A column called "mz" is required with the correspoinding mass of each feature.


@return The same feature table with two extra column with matched metabolites (HMDB code and assignation).

## Code to run

```{r Annotation}
# Targeted annotation
# metabolites <- read.csv("C:/Users/fmadrid/Documents/IBEC/NESTLE/LCMS/20200128_Data_IBEC_Plasma_LCMS/known_metabolites.csv")

# Untargeted assignation
# Creating mz column
mzr <- colnames(xdata_reduced) %>%
  stringr::str_split(.,"\\_") %>% 
  lapply(.,function(x) x[1]) %>% 
  unlist() %>% 
  # substring(., 2) %>% # add if xdata was loaded (cols with an X)
  as.numeric()

all.equal(dim(xdata_reduced)[2], length(mzr))

# Creating rt column
rtr <- colnames(xdata_reduced) %>%
  stringr::str_split(.,"\\_") %>% 
  lapply(.,function(x) x[2]) %>% 
  unlist() %>% 
  # substring(., 2) %>% # add if xdata was loaded (cols with an X)
  as.numeric()
rtr <- rtr/60

all.equal(dim(xdata_reduced)[2], length(rtr))

# Merging columns
tdata_reduced <- t(xdata_reduced)
tdata_reduced <- as.data.frame(cbind(mz = mzr, tdata_reduced))
tdata_reduced <- cbind(rt = rtr, tdata_reduced)
tdata_reduced <- cbind(features = rownames(tdata_reduced), tdata_reduced)

result_POS_HMDB <- assignation_pos_HMDB(tdata_reduced)

head(result_POS_HMDB[1:5,15:length(result_POS_HMDB)])
```

# Targeted identification

```{r}
metabolites <- read.csv("C:/Users/hgrac/Desktop/cosas/IBEC/NIHSI/known_metabolites.csv")
#metabolites <- read.csv("C:/Users/fmadrid/Documents/IBEC/NESTLE/LCMS/20200128_Data_IBEC_Plasma_LCMS/known_metabolites.csv")
head(metabolites)

targeted <- NIHSlcms::known_metabolites(tdata_reduced,
                                        metabolites)

```


# Principal Component Analysis

```{r}
library(mixOmics)

xdata_reduced_rows <- cbind(sampleNames = 
                              rownames(xdata_reduced),
                            xdata_reduced)

suppressWarnings(
  xdata_reduc_comp_meta <- dplyr::right_join(
    metadata, 
    xdata_reduced_rows, 
    by = "sampleNames", 
    all = TRUE))

newmz <- c(colnames(xdata_reduc_comp_meta[1:7]), mzr)
newrt <- c(colnames(xdata_reduc_comp_meta[1:7]), rtr)
reduced_data_comp <- rbind(newrt, xdata_reduc_comp_meta)
reduced_data_comp <- rbind(newmz, reduced_data_comp)


pca_plot <- mixOmics::pca(xdata_reduc_comp_meta[,-1:-7],
                          ncomp = 2, 
                          center = TRUE, 
                          scale = TRUE)
print(pca_plot)

plot_PCAtreat <- mixOmics::plotIndiv (pca_plot, 
                     style = "graphics", 
                    ind.names = xdata_reduc_comp_meta$treatment,
                     group = xdata_reduc_comp_meta$treatment,
                     legend = FALSE,  
                     X.label = "PC 1", 
                     Y.label = "PC 2", 
                     title = "Scaled data")

pca_plot <- mixOmics::pca(xdata_reduc_comp_meta[,-1:-7],
                          ncomp = 2, 
                          center = TRUE, 
                          scale = FALSE)
print(pca_plot)

plot_PCAvol <- mixOmics::plotIndiv (pca_plot, 
                     style = "graphics", 
                     ind.names = xdata_reduc_comp_meta$Vplasma,
                     group = xdata_reduc_comp_meta$treatment, 
                     legend = FALSE,  
                     X.label = "PC 1", 
                     Y.label = "PC 2", 
                     title = "Scaled data, vol of plasma")
```

## Save results

```{r}
output_dir_node10 <- file.path(output_dir, "10-identification")
fs::dir_create(output_dir_node10)

result_POS_HMDB_fn <- file.path(output_dir_node10,
                               "result_POS_HMDB.csv")
utils::write.csv(result_POS_HMDB, 
                 result_POS_HMDB_fn, 
                 row.names = FALSE)

targeted_fn <- file.path(output_dir_node10,
                               "targeted_results.csv")
utils::write.csv(targeted, 
                 targeted_fn, 
                 row.names = FALSE)

xdata_reduc_comp_meta_fn <- file.path(output_dir_node10,
                               "xdata_reduc_comp_meta.csv")
utils::write.csv(xdata_reduc_comp_meta, 
                 xdata_reduc_comp_meta_fn, 
                 row.names = FALSE)

reduced_data_comp_fn <- file.path(output_dir_node10,
                               "xdata_reduc_comp_meta_MzRt.csv")
utils::write.csv(reduced_data_comp, 
                 reduced_data_comp_fn, 
                 row.names = FALSE)
```

