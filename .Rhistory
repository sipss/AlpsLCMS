}
output_dir_node5 <- file.path(output_dir, "05-MAIT")
fs::dir_create(output_dir_node5)
to_MAIT <- function (dataDir = NULL, project = NULL, preproc_params = NULL,  peakTable = NULL){
parameters <- c(dataDir = dataDir, preproc_params)
if (is.null(dataDir)) {
stop("No input directory was given")
}
if (is.null(project)) {
stop("No project name was included")
}
if (is.null(preproc_params)) {
stop("No parameters for preprocessing were included")
}
if (is.null(peakTable)) {
stop("No peak was included")
}
MAIT.object <- new("MAIT")
MAIT.object@RawData@parameters@sampleProcessing <- parameters
writeParameterTable(parameters(MAIT.object), folder = resultsPath(MAIT.object)) # warning: resultsPath
class <- list.files(dataDir)
classNum <- vector(length = length(class))
fileList <- list.files(path = paste(dataDir, list.files(path = dataDir),
sep = "/"), full.names = TRUE)
for (i in 1:length(class)) {
classNum[i] <- length(list.files(paste(dataDir, list.files(dataDir)[i],
sep = "/")))
}
classes <- rep(class, classNum)
if (length(list.files(dataDir)) == 1) {
warning("Warning: Input data only has one class!")
}
if (is.null(project)) {
warning("Warning: Project name is empty!")
}
if (!is.null(project)) {
resultsPath <- paste("Results", project, sep = "_")
dir.create(resultsPath)
}
else {
resultsPath <- "Results"
dir.create(resultsPath)
}
peakTable <- as(peakTable, "xcmsSet")
peakTable <- fillPeaks(peakTable)
fPeaks <- list(peakTable)
names(fPeaks) <- "xcmsSet"
MAIT.object@RawData@data <- fPeaks
MAIT.object@PhenoData@classes <- class
MAIT.object@PhenoData@classNum <- classNum
MAIT.object@PhenoData@resultsPath <- resultsPath
MAIT <- MAIT.object
}
peak_table_pos_MAIT <- to_MAIT(output_dir_node5, project, preproc_params, peak_table_pos)
project <- "LUMOS"
output_dir_node5 <- file.path(output_dir, "05-MAIT")
fs::dir_create(output_dir_node5)
to_MAIT <- function (dataDir = NULL, project = NULL, preproc_params = NULL,  peakTable = NULL){
parameters <- c(dataDir = dataDir, preproc_params)
if (is.null(dataDir)) {
stop("No input directory was given")
}
if (is.null(project)) {
stop("No project name was included")
}
if (is.null(preproc_params)) {
stop("No parameters for preprocessing were included")
}
if (is.null(peakTable)) {
stop("No peak was included")
}
MAIT.object <- new("MAIT")
MAIT.object@RawData@parameters@sampleProcessing <- parameters
writeParameterTable(parameters(MAIT.object), folder = resultsPath(MAIT.object)) # warning: resultsPath
class <- list.files(dataDir)
classNum <- vector(length = length(class))
fileList <- list.files(path = paste(dataDir, list.files(path = dataDir),
sep = "/"), full.names = TRUE)
for (i in 1:length(class)) {
classNum[i] <- length(list.files(paste(dataDir, list.files(dataDir)[i],
sep = "/")))
}
classes <- rep(class, classNum)
if (length(list.files(dataDir)) == 1) {
warning("Warning: Input data only has one class!")
}
if (is.null(project)) {
warning("Warning: Project name is empty!")
}
if (!is.null(project)) {
resultsPath <- paste("Results", project, sep = "_")
dir.create(resultsPath)
}
else {
resultsPath <- "Results"
dir.create(resultsPath)
}
peakTable <- as(peakTable, "xcmsSet")
peakTable <- fillPeaks(peakTable)
fPeaks <- list(peakTable)
names(fPeaks) <- "xcmsSet"
MAIT.object@RawData@data <- fPeaks
MAIT.object@PhenoData@classes <- class
MAIT.object@PhenoData@classNum <- classNum
MAIT.object@PhenoData@resultsPath <- resultsPath
MAIT <- MAIT.object
}
peak_table_pos_MAIT <- to_MAIT(output_dir_node5, project, preproc_params, peak_table_pos)
peak_table_pos_ANN <- peakAnnotation(MAIT.object = peak_table_pos_MAIT,
corrWithSamp = 0.7,
corrBetSamp = 0.75,
perfwhm = 0.6)
rawData(peak_table_pos_ANN)
peak_table_pos_ANN <- spectralSigFeatures(MAIT.object = peak_table_pos_ANN,
pvalue=0.05,
p.adj="none",
scale=FALSE)
peak_table_pos_ANN <- spectralSigFeatures(MAIT.object = peak_table_pos_ANN,
pvalue=0.05,
p.adj="none",
scale=FALSE)
peak_table_pos_ANN
peak_table_pos_ANN
output_dir_node4 <- file.path(output_dir, "04-XCMS")
fs::dir_create(output_dir_node4)
rearrange_datafiles_by_class(dataset_pos, dataDir = output_dir_node4)
project <- "LUMOS"
dataDir = output_dir_node4
fileList <- list.files(path = paste(dataDir, list.files(path = dataDir),
sep = "/"), full.names = TRUE)
fileList
writeParameterTable <- function(listParameters,folder){
outputTable <- as.matrix(c(unlist(listParameters@sampleProcessing),unlist(listParameters@peakAnnotation),                               unlist(listParameters@peakAggregation),unlist(listParameters@sigFeatures),                                          unlist(listParameters@biotransformations),unlist(listParameters@identifyMetabolites),
unlist(listParameters@classification),unlist(listParameters@plotPCA),
unlist(listParameters@plotHeatmap)))
colnames(outputTable) <- c("Value")
write.csv(file=paste(folder,"MAITparameters.csv",sep="/"),outputTable)
return(outputTable)
}
output_dir_node5 <- file.path(output_dir, "05-MAIT")
fs::dir_create(output_dir_node5)
to_MAIT <- function (dataDir = NULL, project = NULL, preproc_params = NULL,  peakTable = NULL){
parameters <- c(dataDir = dataDir, preproc_params)
if (is.null(dataDir)) {
stop("No input directory was given")
}
if (is.null(project)) {
stop("No project name was included")
}
if (is.null(preproc_params)) {
stop("No parameters for preprocessing were included")
}
if (is.null(peakTable)) {
stop("No peak was included")
}
MAIT.object <- new("MAIT")
MAIT.object@RawData@parameters@sampleProcessing <- parameters
writeParameterTable(parameters(MAIT.object), folder = resultsPath(MAIT.object)) # warning: resultsPath
class <- list.files(dataDir)
classNum <- vector(length = length(class))
fileList <- list.files(path = paste(dataDir, list.files(path = dataDir),
sep = "/"), full.names = TRUE)
for (i in 1:length(class)) {
classNum[i] <- length(list.files(paste(dataDir, list.files(dataDir)[i],
sep = "/")))
}
classes <- rep(class, classNum)
if (length(list.files(dataDir)) == 1) {
warning("Warning: Input data only has one class!")
}
if (is.null(project)) {
warning("Warning: Project name is empty!")
}
if (!is.null(project)) {
resultsPath <- paste("Results", project, sep = "_")
dir.create(resultsPath)
}
else {
resultsPath <- "Results"
dir.create(resultsPath)
}
peakTable <- as(peakTable, "xcmsSet")
peakTable <- fillPeaks(peakTable)
fPeaks <- list(peakTable)
names(fPeaks) <- "xcmsSet"
MAIT.object@RawData@data <- fPeaks
MAIT.object@PhenoData@classes <- class
MAIT.object@PhenoData@classNum <- classNum
MAIT.object@PhenoData@resultsPath <- resultsPath
MAIT <- MAIT.object
}
#?
peak_table_pos_MAIT <- to_MAIT(output_dir_node4, project, preproc_params, peak_table_pos)
peak_table_pos_MAIT
peak_table_pos_ANN <- peakAnnotation(MAIT.object = peak_table_pos_MAIT,
corrWithSamp = 0.7,
corrBetSamp = 0.75,
perfwhm = 0.6)
rawData(peak_table_pos_ANN)
peak_table_pos_ANN <- spectralSigFeatures(MAIT.object = peak_table_pos_ANN,
pvalue=0.05,
p.adj="none",
scale=FALSE)
peak_table_pos_ANN
peak_table_pos_ANN <- spectralSigFeatures(MAIT.object = peak_table_pos_ANN,
pvalue= 0.05,
p.adj= "none",
scale= FALSE)
peak_table_pos_ANN
View(peak_table_pos_ANN)
peak_table_pos_ANN <- spectralSigFeatures(MAIT.object = peak_table_pos_ANN,
pvalue= 0.05,
p.adj= "none",
scale= FALSE)
summary(peak_table_pos_ANN)
signTable <- sigPeaksTable(MAIT.object = peak_table_pos_ANN,
printCSVfile = FALSE)
peak_table_pos_MAIT
peak_table_pos_ANN <- peakAnnotation(MAIT.object = peak_table_pos_MAIT,
corrWithSamp = 0.7,
corrBetSamp = 0.75,
perfwhm = 0.6)
rawData(peak_table_pos_ANN)
peak_table_pos_ANN <- spectralSigFeatures(MAIT.object = peak_table_pos_ANN,
pvalue= 0.05,
p.adj= "none",
scale= FALSE)
peak_table_pos_ANN
peak_table_pos_ANN <- spectralSigFeatures(MAIT.object = peak_table_pos_ANN,
pvalue= 0.05,
p.adj= "none",
scale= FALSE)
View(peak_table_pos_ANN)
sum(is.na(featureValues(peak_table_pos)))
peak_table_pos <- fillChromPeaks(peak_table_pos) # Imputation of peaks
register(SerialParam())
sum(is.na(featureValues(peak_table_pos)))
peak_table_pos <- fillChromPeaks(peak_table_pos) # Imputation of peaks
View(dataset_pos)
sum(is.na(featureValues(peak_table_pos)))
peak_table_pos <- fillChromPeaks(peak_table_pos) # Imputation of peaks
register(SerialParam())
sum(is.na(featureValues(peak_table_pos)))
peak_table_pos <- fillChromPeaks(peak_table_pos) # Imputation of peaks
View(dataset_pos)
peak_table_pos <- fillChromPeaks(peak_table_pos, param = preproc_params) # Imputation of peaks
peak_table_pos <- fillChromPeaks(peak_table_pos, rtlim = c(4,14)) # Imputation of peaks
peak_table_pos <- fillChromPeaks(peak_table_pos) # Imputation of peaks
peak_table_pos1 <- fillChromPeaks(peak_table_pos) # Imputation of peaks
tibble::as.tibble(xcms::featureValues(peak_table_pos, value = "into"), rownames = "PeakID")
pdp <- xcms::PeakDensityParam(sampleGroups = peakdet_pos_align_no_blanks$treatment,
binSize = preproc_params$mzwid,
minFraction = preproc_params$minFraction,
minSamples = preproc_params$minSamples,
maxFeatures =preproc_params$maxFeatures,
bw = preproc_params$bw)
peak_table_pos <- xcms::groupChromPeaks(peakdet_pos_align_no_blanks, param = pdp)
tibble::as.tibble(xcms::featureValues(peak_table_pos, value = "into"), rownames = "PeakID")
peakdet_pos_align_no_blanks
# obiwarp_params <- xcms::ObiwarpParam(binSize = preproc_params$profStep,
#                                      centerSample = preproc_params$centerSample,
#                                      response = preproc_params$response,
#                                      distFun = preproc_params$distFun,
#                                      gapInit = preproc_params$gapInit,
#                                      gapExtend = preproc_params$gapExtend,
#                                      factorDiag = preproc_params$factorDiag,
#                                      factorGap = preproc_params$factorGap,
#                                      localAlignment = preproc_params$localAlignment,
#                                      initPenalty = preproc_params$initPenalty)
# peakdet_pos_align_no_blanks <- xcms::adjustRtime(peakdet_pos_no_blanks, param = obiwarp_params)
peakdet_pos_align_no_blanks = align_Rtime(peakdet_pos_no_blanks, params = preproc_params)
min2sec <- 60
rtc_df <-  tibble::tibble(
fileIdx = fData(peakdet_pos_align_no_blanks)$fileIdx,
treatment = pData(peakdet_pos_align_no_blanks)$treatment[fileIdx],
ret_time_adj = MSnbase::rtime(peakdet_pos_align_no_blanks, adjust = TRUE),
ret_time_orig = MSnbase::rtime(peakdet_pos_align_no_blanks, adjust = FALSE)
)
rt <- round(base::range(rtc_df$ret_time_orig) / min2sec)
tick_values <- seq(from = rt[1], to = rt[2], by = 2)
ggplot(rtc_df) +
geom_line(aes(x = ret_time_orig / min2sec, y = (ret_time_adj-ret_time_orig), color = treatment, group = fileIdx)) +
scale_x_continuous("Original retention time (min.)", limits = rt, breaks = tick_values) + #limits = rt, breaks = tick_values
scale_y_continuous("Retention time correction (s)") +
ggtitle("Retention time alignment warping for each sample")
pdp <- xcms::PeakDensityParam(sampleGroups = peakdet_pos_align_no_blanks$treatment,
binSize = preproc_params$mzwid,
minFraction = preproc_params$minFraction,
minSamples = preproc_params$minSamples,
maxFeatures =preproc_params$maxFeatures,
bw = preproc_params$bw)
peak_table_pos <- xcms::groupChromPeaks(peakdet_pos_align_no_blanks, param = pdp)
tibble::as.tibble(xcms::featureValues(peak_table_pos, value = "into"), rownames = "PeakID")
tibble::as.tibble(xcms::featureDefinitions(peak_table_pos), rownames = "PeakID")
register(SerialParam())
sum(is.na(featureValues(peak_table_pos)))
peak_table_pos1 <- fillChromPeaks(peak_table_pos) # Imputation of peaks
peak_table_pos1 <- fillChromPeaks(peak_table_pos) # Imputation of peaks
tibble::as.tibble(xcms::featureDefinitions(peak_table_pos), rownames = "PeakID")
peak_table_pos1 <- fillChromPeaks(peak_table_pos) # Imputation of peaks
sum(is.na(featureValues(peak_table_pos)))
output_dir_node5 <- file.path(output_dir, "05-MAIT")
fs::dir_create(output_dir_node5)
to_MAIT <- function (dataDir = NULL, project = NULL, preproc_params = NULL,  peakTable = NULL){
parameters <- c(dataDir = dataDir, preproc_params)
if (is.null(dataDir)) {
stop("No input directory was given")
}
if (is.null(project)) {
stop("No project name was included")
}
if (is.null(preproc_params)) {
stop("No parameters for preprocessing were included")
}
if (is.null(peakTable)) {
stop("No peak was included")
}
MAIT.object <- new("MAIT")
MAIT.object@RawData@parameters@sampleProcessing <- parameters
writeParameterTable(parameters(MAIT.object), folder = resultsPath(MAIT.object)) # warning: resultsPath
class <- list.files(dataDir)
classNum <- vector(length = length(class))
fileList <- list.files(path = paste(dataDir, list.files(path = dataDir),
sep = "/"), full.names = TRUE)
for (i in 1:length(class)) {
classNum[i] <- length(list.files(paste(dataDir, list.files(dataDir)[i],
sep = "/")))
}
classes <- rep(class, classNum)
if (length(list.files(dataDir)) == 1) {
warning("Warning: Input data only has one class!")
}
if (is.null(project)) {
warning("Warning: Project name is empty!")
}
if (!is.null(project)) {
resultsPath <- paste("Results", project, sep = "_")
dir.create(resultsPath)
}
else {
resultsPath <- "Results"
dir.create(resultsPath)
}
peakTable <- as(peakTable, "xcmsSet")
peakTable <- fillPeaks(peakTable)
fPeaks <- list(peakTable)
names(fPeaks) <- "xcmsSet"
MAIT.object@RawData@data <- fPeaks
MAIT.object@PhenoData@classes <- class
MAIT.object@PhenoData@classNum <- classNum
MAIT.object@PhenoData@resultsPath <- resultsPath
MAIT <- MAIT.object
}
#?
peak_table_pos_MAIT <- to_MAIT(output_dir_node4, project, preproc_params, peak_table_pos)
peak_table_pos_ANN <- peakAnnotation(MAIT.object = peak_table_pos_MAIT,
corrWithSamp = 0.7,
corrBetSamp = 0.75,
perfwhm = 0.6)
rawData(peak_table_pos_ANN)
peak_table_pos_ANN <- spectralSigFeatures(MAIT.object = peak_table_pos_ANN,
pvalue=0.05,
p.adj="none",
scale=FALSE)
View(peak_table_pos_ANN)
summary(peak_table_pos_ANN)
signTable <- sigPeaksTable(MAIT.object = peak_table_pos_ANN,
printCSVfile = FALSE)
lcms_plotBoxPlot(MAIT.object = peak_table_pos_ANN, treatment_col)
lcms_plotBoxPlot <- function (MAIT.object = NULL, treatment_col) {
if (is.null(treatment_col)) {
stop("No input treatment column was given")
}
if (is.null(MAIT.object)) {
stop("No input MAIT object file was given")
}
if (length(featureSigID(MAIT.object)) == 0) {
stop("No significant features found in the MAIT object. Make sure that functions peakAnnotation and peakAggregation were launched")
}
data <- scores(MAIT.object)
index <- featureSigID(MAIT.object)
class <- classes(MAIT.object)
classNum <- classNum(MAIT.object)
resultsPath <- resultsPath(MAIT.object)
clases <- matrix(nrow = 1)
for (i in c(1:length(class))) {
clases <- c(clases, rep(class[i], classNum[i]))
}
clases <- clases[-1]
clases <- as.factor(clases)
aux <- t(data[index, ])
if (!file.exists(paste(resultsPath, "Boxplots", sep = "/"))) {
dir.create(paste(resultsPath, "Boxplots", sep = "/"))
}else {
cat(" ", fill = TRUE)
cat(paste("Warning: Folder", paste(resultsPath, "Boxplots",
sep = "/"), "already exists. Possible file overwritting.",
sep = " "), fill = TRUE)
}
for (i in c(1:length(index))) {
peaks_df <- data.frame(peaks = aux[,i],
treatment = clases,
stringsAsFactors = FALSE)
ggplot(peaks_df) +
geom_boxplot(aes(x = treatment, y = peaks, fill = treatment)) +
scale_fill_manual("Treatment", values = treatment_col) +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
ggtitle(paste("Boxplot of the Spectra", index[i]))
base::suppressWarnings(
base::suppressMessages(ggsave(paste(paste(resultsPath, "Boxplots/Boxplot_spectra_",
sep = "/"), index[i], ".png", sep = ""))))
}
}
lcms_plotBoxPlot(MAIT.object = peak_table_pos_ANN, treatment_col)
min2sec <- 60
rtc_df <-  tibble::tibble(
fileIdx = fData(peakdet_pos_align_no_blanks)$fileIdx,
treatment = pData(peakdet_pos_align_no_blanks)$treatment[fileIdx],
ret_time_adj = MSnbase::rtime(peakdet_pos_align_no_blanks, adjust = TRUE),
ret_time_orig = MSnbase::rtime(peakdet_pos_align_no_blanks, adjust = FALSE)
)
rt <- round(base::range(rtc_df$ret_time_orig) / min2sec)
tick_values <- seq(from = rt[1], to = rt[2], by = 2)
ggplot(rtc_df) +
geom_line(aes(x = ret_time_orig / min2sec, y = (ret_time_adj-ret_time_orig), color = treatment, group = fileIdx)) +
scale_x_continuous("Original retention time (min.)", limits = rt, breaks = tick_values) + #limits = rt, breaks = tick_values
scale_y_continuous("Retention time correction (s)") +
ggtitle("Retention time alignment warping for each sample")
pdp <- xcms::PeakDensityParam(sampleGroups = peakdet_pos_align_no_blanks$treatment,
binSize = preproc_params$mzwid,
minFraction = preproc_params$minFraction,
minSamples = preproc_params$minSamples,
maxFeatures =preproc_params$maxFeatures,
bw = preproc_params$bw)
peak_table_neg <- xcms::groupChromPeaks(peakdet_pos_align_no_blanks, param = pdp)
tibble::as.tibble(xcms::featureValues(peak_table_neg, value = "into"), rownames = "PeakID")
tibble::as.tibble(xcms::featureDefinitions(peak_table_neg), rownames = "PeakID")
lcms_plotChrom <- function (chromatogram,treatment_col, rtlim = NULL){
min2sec <- 60
#we need to modify this in order to be more flexible (treatment_col)
ret_times <- lapply(chromatogram, FUN = rtime)
intensities <- lapply(chromatogram, FUN = intensity)
plot(ret_times[[1]] / min2sec, intensities[[1]], type = "l",
col = treatment_col[chromatogram$treatment][1], lwd = 1,
xlab = "Retention time (min)", ylab = "Intensity  (A.U)",
xlim = rtlim,
main = "Base Peak Chromatogram")
for (i in 2:length(ret_times)){ # we need to modify the sequence using seq_along
points(ret_times[[i]] / min2sec, intensities[[i]], lwd = 1,
xlim = rtlim,
type= "l", col = treatment_col[chromatogram$treatment][i])
legend("topright", legend = names(treatment_col), fill = treatment_col)
}
}
rtlim <- c(4, 14)
base_peaks_neg <- xcms::chromatogram(dataset_neg, aggregationFun = "max")
rtlim <- c(4, 14)
no_blanks <- !(names(treatment_col) %in% as.character(unlist(especial_samples)))
plotChromPeakImageRTmin <- function (x, binSize = 30, xlim = NULL, log = FALSE, xlab = "retention time",
yaxt = par("yaxt"), main = "Chromatographic peak counts",
...)
{
min2sec <- 60
if (!is(x, "XCMSnExp"))
stop("'x' is supposed to be an 'XCMSnExp' object, but I got a ",
class(x))
if (is.null(xlim))
xlim <- c(floor(min(rtime(x))), ceiling(max(rtime(x))))
brks <- seq(xlim[1], xlim[2], by = binSize)
if (brks[length(brks)] < xlim[2])
brks <- c(brks, brks[length(brks)] + binSize)
pks <- chromPeaks(x, rt = xlim)
if (nrow(pks)) {
rts <- split(pks[, "rt"], pks[, "sample"])
cnts <- lapply(rts, function(z) {
hst <- hist(z, breaks = brks, plot = FALSE)
hst$counts
})
n_samples <- length(fileNames(x))
sample_idxs <- 1:n_samples
sample_idxs <- sample_idxs[!(as.character(sample_idxs) %in%
names(rts))]
if (length(sample_idxs)) {
all_cnts <- vector("list", n_samples)
all_cnts[as.numeric(names(cnts))] <- cnts
zeros <- rep(0, (length(brks) - 1))
all_cnts[sample_idxs] <- list(zeros)
cnts <- all_cnts
}
cnts <- t(do.call(rbind, cnts))
if (log)
cnts <- log2(cnts)
image(z = cnts, x = (brks - (brks[2] - brks[1])/2) / min2sec, xaxs = "r",
xlab = xlab, yaxt = "n", ...)
if (yaxt != "n")
axis(side = 2, at = seq(0, 1, length.out = n_samples),
labels = basename(fileNames(x)), las = 2)
}
}
plotChromPeakImageRTmin(peakdet_neg_no_blanks, binSize = 5, xlim = NULL, log = FALSE,
xlab = "retention time (min)", yaxt = par("yaxt"))
plotChromPeakImageRTmin(peakdet_pos_no_blanks, binSize = 5, xlim = NULL, log = FALSE,
xlab = "retention time (min)", yaxt = par("yaxt"))
title(main ="Detected Peaks (Not Aligned)")
plotChromPeakImageRTmin(peakdet_pos_align_no_blanks, binSize = 5, xlim = NULL, log = FALSE,
xlab = "retention time (min)", yaxt = par("yaxt"))
title(main ="Detected Peaks (Aligned)")
peak_table_neg <- fillChromPeaks(peak_table_neg) # Imputation of peaks
peak_table_neg <- fillChromPeaks(peak_table_pos) # Imputation of peaks
save.image("~/IBEC/NESTLE/LCMS/HepG2_output/WS_LCMS.RData")
load("C:/Users/fmadrid/Documents/IBEC/NESTLE/LCMS/HepG2_output/WS_LCMS.RData")
load("C:/Users/fmadrid/Documents/IBEC/NESTLE/LCMS/HepG2_output/WS_LCMS.RData")
