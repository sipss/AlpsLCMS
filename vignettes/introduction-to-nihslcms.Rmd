---
title: "Introduction to NIHSlcms"
author: "Institute for Bioengineering of Catalonia"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to NIHSlcms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  fig.width = 7,
  fig.height = 5,
  collapse = TRUE,
  comment = "#>"
)
```

The `NIHSlcms` package was written with two purposes in mind:

- to help **data analysts and LC-MS scientists** to work with LC-MS samples.
- to help **IT pipeline builders** implement automated methods for preprocessing.

Functions from this package written for data analysts and LC-MS scientists are
prefixed with `lcms_`, while higher level functions written for IT pipeline
builders are prefixed with `pipe_`. The main reason why all exported functions
have a prefix is to make it easy for the user to discover the functions from the
package. By typing lcms_ RStudio will return the list of exported functions. In
the R terminal, lcms_ followed by the tab key (â‡¥) twice will have the same
effect. Other popular packages, follow similar approaches (e.g: `forcats`:
`fct_*`, `stringr`: `str_*`).

This vignette is written for the first group. It assumes some prior basic
knowledge of LC-MS and data analysis, as well as some basic R programming. In case
you are interested in building pipelines with this package, you may want to open
the file saved in this directory (run it on your computer):

```
pipeline_example <- system.file("pipeline-rmd", "pipeline_example.R", package = "NIHSlcms")
print(pipeline_example)
```


```{r}
library(NIHSlcms)
library(ggplot2)
```


# NODE 1: Data wrangling

## Convert RAW to mzXML

First, we need the listed spectra in ".mzXML" format to create the `lcms_dataset`. We can manually convert ".raw" into ".mzXML" using RawConverter or ProteoWizard externally and saved them within the same input directory. We set the polarity manually.

## Input

```{r}
library(faahKO)
path <- dir(system.file("cdf", package = "faahKO"), full.names = TRUE,
            recursive = TRUE)[c(1:3, 7:9)]
polarity <- 1 # 1 for positive mode, 0 for negative mode
```

## Code to run

```{r Data wrangling}
# Be careful setting the mode to "onDisk" when you apply this function.
dataset <- readMSData(path, mode = "onDisk")
dataset@featureData@data[["polarity"]] <- rep(polarity, length(dataset@featureData@data[["polarity"]]))
message("Is the polarity correctly loaded? \n")
cat("\n")
print(dataset)
```


# NODE 2: Append metadata

To merge the metadata, an Excel o CSV file is required, containing the first column (called "sampleNames") with the same name of the LC-MS files, **ending with the format (e.g. Sample1.mzXML)**.

It requires a column (called "treatment") with the class sample. Ensure you have this specific colname **"treatment"**.

Caution with metadata. The use of characters such as "-", "/", " " (space) and starting with **numbers**, etc. leads to problems. Therefore, the function replace `[\\\"\\s/\\\\,;.:|#@$%&?!*%+-=><^'(){}\\[\\]]+` by `_`. Beware of using other special characters and change them by usual ASCII characters.

## Input parameters

```{r}
metadata <- data.frame(sampleNames = basename(path),
                 treatment = c("ko", "ko", "ko", "wt", "wt", "wt"),
                 stringsAsFactors = FALSE)
```

## Code to run

```{r}
dataset <- lcms_meta_add(dataset, metadata, by = "sampleNames")
phData(dataset)
```


# NODE 3: Total ion chromatogram

```{r}
tics <- lcms_tics(dataset, treatment = "treatment")

lcms_plot_tics(tics,
               treatment = treatment, 
               plot_type = "spec")

lcms_plot_tics(tics, treatment = treatment,
               plot_type = "boxplot")
```


# NODE 4: Filtering

## Filter by retention time / m/z

For coherence with the pipeline, time is measured in minutes. `XCMS` and `IPO` packages work in seconds by default, while `CAMERA` and `MAIT` in minutes. Under the hood, the still do in this way, but we preset all our results in minutes. 


## Input

```{r}
# Range of the retention time (minutes) to include in further analyses
rt = c(50, 70)
ms = c(100, 200)
```

## Code to run

```{r}
dataset_shorter <- lcms_filter_rt_min(dataset, rt = rt)
dataset_shorter <- lcms_filter_mz(dataset_shorter, mz = ms)
tics <- lcms_tics(dataset_shorter, treatment = "treatment")

lcms_plot_tics(tics,
               treatment = treatment, 
               plot_type = "spec")
```


# NODE 5: Optimization of parameters

## Optimization of **Peak Detection** parameters for xcms


## Input

```{r Optimize}
# output_dir_node5_p <- file.path(output_dir, "05-optimization_pos")
# fs::dir_create(output_dir_node5_p)

optimize = TRUE
nSlaves = 1
```

## Code to run

```{r}
default_peakpeaking_params <- lcms_default_peakpicking_params(optimize = optimize)
# 
# default_peakpeaking_params$prefilter <- 3 
# default_peakpeaking_params$value_of_prefilter <- 1000
# default_peakpeaking_params$integrate <- 1
# 
resultPeakpicking <- lcms_peakpicking_optimization(
  dataset = dataset_shorter,
  peakpickingParameters = default_peakpeaking_params,
  nSlaves = nSlaves,
  opt_path = output_dir_node5_p,
  plots = TRUE)
```




## Creating an `nmr_dataset_1D` object from a matrix

You can also create an `nmr_dataset_1D` object from scratch with the
`new_nmr_dataset_1D` function:

```{r}
nsamp <- 12
npoints <- 20
# Create a random spectra matrix
dummy_ppm_axis <- seq(from = 0.2, to = 10, length.out = npoints)
dummy_spectra_matrix <- matrix(runif(nsamp*npoints), nrow = nsamp, ncol = npoints)
metadata <- list(external = data.frame(NMRExperiment = paste0("Sample", 1:12),
                                       DummyClass = c("a", "b"),
                                       stringsAsFactors = FALSE))
your_custom_nmr_dataset_1D <- new_nmr_dataset_1D(ppm_axis = dummy_ppm_axis,
                                                 data_1r = dummy_spectra_matrix,
                                                 metadata = metadata)
print(your_custom_nmr_dataset_1D)
plot(your_custom_nmr_dataset_1D) +
  ggtitle("Of course those random values don't make much sense...")
```


# Final thoughts

This vignette shows many of the features of the package, some features have
room for improvement, others are not fully described, and the reader will need
to browse the documentation. Hopefully it is a good starting point for using the
package.


